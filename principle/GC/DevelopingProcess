Go V1.3之前的标记-清除(mark and sweep)算法

第一步，暂停程序业务逻辑, 找出不可达的对象，然后做上标记.
第二步, 开始标记，程序找出它所有可达的对象，并做上标记.
第三步, 标记完了之后，然后开始清除未标记的对象.
第四步, 停止暂停，让程序继续跑.然后循环重复这个过程，直到process程序生命周期结束.

标记-清扫(mark and sweep)的缺点：
STW，stop the world；让程序暂停，程序出现卡顿 (重要问题).
标记需要扫描整个heap
清除数据会产生heap碎片

Go V1.5的三色并发标记法
第一步 , 就是只要是新创建的对象,默认的颜色都是标记为“白色”.
第二步, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合.
第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合.
第四步, 重复第三步, 直到灰色中无任何对象.

没有STW的三色标记法
可以看出，有两个问题, 在三色标记法中,是不希望被发生的

条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**
条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**

当以上两个条件同时满足时, 就会出现对象丢失现象!
​
当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.
​为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？

​答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.

屏障机制

1.强三色不变式
不存在黑色对象引用到白色对象的指针.
2.弱三色不变式
所有被黑色对象引用的白色对象都处于灰色保护状态.

1.插入屏障
具体操作: 在A对象引用B对象的时候，B对象被标记为灰色.(将B挂在A下游，B必须被标记为灰色)

满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

2.删除屏障
具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色.

满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)

Go V1.8的混合写屏障(hybrid write barrier)机制

插入写屏障和删除写屏障的短板：

插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；

删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象.
Go V1.8版本引入了混合写屏障机制(hybrid write barrier)，避免了对栈re-scan的过程，极大的减少了STW的时间.结合了两者的优点.

混合写屏障规则
具体操作:

1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何在栈上创建的新对象，均为黑色.

3、被删除的对象标记为灰色.

4、被添加的对象标记为灰色.

满足: 变形的弱三色不变式.

总结

GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低.

GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通

GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动.整个过程几乎不需要STW，效率较高.
